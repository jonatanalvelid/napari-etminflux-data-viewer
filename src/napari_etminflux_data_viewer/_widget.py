"""
This module contains four napari widgets declared in
different ways:

- a pure Python function flagged with `autogenerate: true`
    in the plugin manifest. Type annotations are used by
    magicgui to generate widgets for each parameter. Best
    suited for simple processing tasks - usually taking
    in and/or returning a layer.
- a `magic_factory` decorated function. The `magic_factory`
    decorator allows us to customize aspects of the resulting
    GUI, including the widgets associated with each parameter.
    Best used when you have a very simple processing task,
    but want some control over the autogenerated widgets. If you
    find yourself needing to define lots of nested functions to achieve
    your functionality, maybe look at the `Container` widget!
- a `magicgui.widgets.Container` subclass. This provides lots
    of flexibility and customization options while still supporting
    `magicgui` widgets and convenience methods for creating widgets
    from type annotations. If you want to customize your widgets and
    connect callbacks, this is the best widget option for you.
- a `QWidget` subclass. This provides maximal flexibility but requires
    full specification of widget layouts, callbacks, events, etc.

References:
- Widget specification: https://napari.org/stable/plugins/building_a_plugin/guides.html#widgets
- magicgui docs: https://pyapp-kit.github.io/magicgui/

Replace code below according to your needs.
"""

import os
from typing import TYPE_CHECKING

import numpy as np
import tifffile
from magicgui.widgets import CheckBox, Container, create_widget
from qtpy.QtWidgets import (
    QComboBox,
    QFileDialog,
    QGridLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QTextBrowser,
    QWidget,
)
from skimage.util import img_as_float

from . import obf_support

if TYPE_CHECKING:
    import napari


class LoaderWidget(QWidget):
    """A widget to load etMINFLUX event files into napari. Currently only simple etMINFLUX experiments with a single ROI per event are supported."""

    def __init__(self, viewer: "napari.viewer.Viewer"):
        super().__init__()
        self.viewer = viewer

        self.folderField = QLineEdit()
        self.folderField.setReadOnly(True)

        self.loadFolderButton = QPushButton("Load folder")
        self.loadFolderButton.clicked.connect(self._list_events_from_folder)

        self.loadEventButton = QPushButton("Load event")
        self.loadEventButton.clicked.connect(self._load_event)

        # add all events in a dropdown list
        self.events = []
        self.eventsPar = QComboBox()
        self.eventsParLabel = QLabel("Events in folder")

        # add recording modes in dropdown list
        self.recordingModes = [
            "Single",
            "MultiROI",
            "SingleROIFollow",
            "MultiROIFollow",
        ]
        self.recordingModesPar = QComboBox()
        self.recordingModesPar.addItems(self.recordingModes)
        self.recordingModesParLabel = QLabel("Recording mode")

        # create text browser for info from event log file
        self.logTextBrowser = QTextBrowser()

        self.eventsPath = None

        self.currentImage = None
        self.currentTracks = None

        # create grid and grid layout
        self.grid = QGridLayout()
        self.setLayout(self.grid)

        self.layout().addWidget(self.folderField, 0, 0, 1, 2)
        self.layout().addWidget(self.loadFolderButton, 1, 0, 1, 2)
        self.layout().addWidget(self.eventsParLabel, 2, 0)
        self.layout().addWidget(self.eventsPar, 2, 1)
        self.layout().addWidget(self.recordingModesParLabel, 3, 0)
        self.layout().addWidget(self.recordingModesPar, 3, 1)
        self.layout().addWidget(self.loadEventButton, 4, 0, 1, 2)
        self.layout().addWidget(self.logTextBrowser, 5, 0, 1, 2)

    def _list_events_from_folder(self):
        self.eventsPath = QFileDialog.getExistingDirectory(
            caption="Choose folder with events"
        )
        self.folderField.setText(self.eventsPath)
        self.events = []
        for msrfile in [
            file
            for file in os.listdir(self.eventsPath)
            if file.endswith(".msr")
        ]:
            if os.path.isfile(os.path.join(self.eventsPath, msrfile)):
                event_name = msrfile.split(".")[0].split("_")[0]
                self.events.append(event_name)
        self.eventsPar.clear()
        self.eventsPar.addItems(self.events)
        self.eventsPar.setCurrentIndex(0)
        print(f"Loading events from folder: {self.eventsPath}")

    def _set_logbrowser_text(self, filepath):
        with open(filepath) as f:
            text = f.read()
        self.logTextBrowser.setPlainText(text)

    def _load_event(self):
        # set default plotting params
        tail_width = 0.05
        tail_length = 20
        head_length = 3
        opacity = 0.8

        # check if an event is already loaded, and if so, remove it
        if self.currentImage is not None:
            self.viewer.layers.remove(self.currentImage)
            self.currentImage = None
        if self.currentTracks is not None:
            for trackslayer in self.currentTracks:
                self.viewer.layers.remove(trackslayer)
            self.currentTracks = None

        # list all available relevant files in the folder
        msrfiles = [
            file
            for file in os.listdir(self.eventsPath)
            if file.endswith(".msr")
        ]
        npyfiles = [
            file
            for file in os.listdir(self.eventsPath)
            if file.endswith(".npy")
        ]
        confrawfiles = [
            file
            for file in os.listdir(self.eventsPath)
            if file.endswith(".tif") and "raw" in file
        ]
        logfiles = [
            file
            for file in os.listdir(self.eventsPath)
            if file.endswith(".txt") and "log" in file
        ]
        selected_event = self.eventsPar.currentText()
        selected_event_date = int(selected_event.split("-")[0])
        selected_event_time = int(selected_event.split("-")[1])
        selected_event_id = self.eventsPar.currentIndex()

        # check which recording mode was used to record the data
        recording_mode = self.recordingModesPar.currentText()
        print(f"Recording mode: {recording_mode}")

        eventmsrfile = msrfiles[selected_event_id]
        eventconfrawfile = confrawfiles[selected_event_id]
        eventlogfile = logfiles[selected_event_id]
        self._set_logbrowser_text(os.path.join(self.eventsPath, eventlogfile))

        # load msr file and read confocal metadata
        msr_dataset = obf_support.File(
            os.path.join(self.eventsPath, eventmsrfile)
        )
        conf_msr_stack_index = 0  # in current imspector templ file, conf dataset always 0; might change with other templ
        conf_stack = msr_dataset.stacks[conf_msr_stack_index]
        pxsize = conf_stack.pixel_sizes[0] * 1e6
        pxshift = pxsize / 2
        conf_size_px = (conf_stack.shape[0], conf_stack.shape[1])
        conf_size = (conf_stack.lengths[0] * 1e6, conf_stack.lengths[1] * 1e6)
        conf_offset = (
            conf_stack.offsets[0] * 1e6,
            conf_stack.offsets[1] * 1e6,
        )
        print(f"MSR file loaded: {msr_dataset}")
        print(
            f"Confocal stack info - size: {conf_size_px[0]}x{conf_size_px[1]} pixels, physical size: {conf_size[0]}x{conf_size[1]} um, pixel size: {pxsize} um, offset: {conf_offset} um"
        )

        # load triggering confocal raw image
        image_conf = np.swapaxes(
            tifffile.imread(os.path.join(self.eventsPath, eventconfrawfile))[
                -1
            ],
            1,
            0,
        )
        self.currentImage = self.viewer.add_image(
            image_conf,
            name=f"confocal-event{selected_event_id}",
            colormap="gray",
            blending="additive",
            contrast_limits=[0, np.max(image_conf)],
        )
        self.currentImage.scale = (pxsize, pxsize)
        self.currentImage.translate = (
            conf_offset[0] + pxshift,
            conf_offset[1] + pxshift,
        )
        print(
            f"Confocal image added to viewer: {image_conf.shape[0]}x{image_conf.shape[1]} pixels, pixel size: {pxsize} um, offset: {conf_offset} um"
        )

        if recording_mode == "Single":
            # load MINFLUX localization data of selected event
            eventnpyfile = npyfiles[selected_event_id]
            tracks, track_ids = self._load_MINFLUX_loc_data(eventnpyfile)
            # add tracks to viewer
            self.currentTracks = []
            self.currentTracks.append(
                self.viewer.add_tracks(
                    tracks,
                    name=f"minflux-tracks-event{selected_event_id}",
                    tail_width=tail_width,
                    tail_length=tail_length,
                    head_length=head_length,
                    opacity=opacity,
                    blending="translucent",
                    color_by="track_id",
                )
            )
            print(
                f"Tracks added to viewer: {tracks.shape[0]} vertices, {len(track_ids)} tracks"
            )
        elif recording_mode == "MultiROI":
            # get date and time of selected event, and find all corresponding ROI npy files
            if self.eventsPar.currentIndex() > 0:
                conf_date_prev = int(
                    self.events[self.eventsPar.currentIndex() - 1].split("-")[
                        0
                    ]
                )
            else:
                conf_date_prev = 0
            if (
                self.eventsPar.currentIndex() > 0
                and selected_event_date == conf_date_prev
            ):
                conf_time_prev = int(
                    self.events[self.eventsPar.currentIndex() - 1].split("-")[
                        1
                    ]
                )
            else:
                conf_time_prev = 0
            eventnpyfiles = [
                file
                for file in npyfiles
                if int(file.split("-")[0]) == selected_event_date
                and int(file.split("-")[1].split("_")[0]) > conf_time_prev
                and int(file.split("-")[1].split("_")[0]) < selected_event_time
            ]

            # loop through event npy files and add tracks to separate layers
            self.currentTracks = []
            for eventnpyfile in eventnpyfiles:
                roi_idx = int(eventnpyfile.split("ROI")[1].split("-")[0])
                # load MINFLUX localization data
                tracks, track_ids = self._load_MINFLUX_loc_data(eventnpyfile)
                # add tracks to viewer
                self.currentTracks.append(
                    self.viewer.add_tracks(
                        tracks,
                        name=f"minflux-tracks-event{selected_event_id}-roi{roi_idx}",
                        tail_width=tail_width,
                        tail_length=tail_length,
                        head_length=head_length,
                        opacity=opacity,
                        blending="translucent",
                        color_by="track_id",
                    )
                )
                print(
                    f"Tracks from roi {roi_idx} added to viewer: {tracks.shape[0]} vertices, {len(track_ids)} tracks"
                )

        # set default dims order to XY instead of YX
        self.viewer.dims.order = (
            1,
            0,
        )

    def _load_MINFLUX_loc_data(self, npyfile, shuffle_ids=True):
        # load MINFLUX localization data
        loc_it = 3  # =4 for default 2D data, =9 for default 3D data
        mfx_dataset = np.load(os.path.join(self.eventsPath, npyfile))
        x = np.zeros((len(mfx_dataset), 1))
        y = np.zeros((len(mfx_dataset), 1))
        tid = np.zeros((len(mfx_dataset), 1))
        tim = np.zeros((len(mfx_dataset), 1))
        for i in range(len(mfx_dataset)):
            x[i] = mfx_dataset[i][0][loc_it][2][0]
            y[i] = mfx_dataset[i][0][loc_it][2][1]
            tid[i] = mfx_dataset[i][4]
            tim[i] = mfx_dataset[i][3]
        x_raw = x * 1e6
        y_raw = y * 1e6
        tid = tid.flatten()
        tim = tim.flatten()
        track_ids = list(map(int, set(tid)))
        track_ids.sort()
        print(
            f"Localization data loaded: {len(mfx_dataset)} localizations, {len(track_ids)} tracks"
        )

        # randomize track IDs, so that plotting colors for each track will not be contiuous along time
        if shuffle_ids:
            unique_ids = np.unique(tid)
            shuffled_ids = np.random.permutation(unique_ids)
            mapping = dict(zip(unique_ids, shuffled_ids, strict=True))
            tid_randomized = np.array([mapping[tid] for tid in tid])
        else:
            tid_randomized = tid

        tracks = np.zeros((len(mfx_dataset), 4))
        tracks[:, 0] = tid_randomized
        tracks[:, 1] = tim
        tracks[:, 2] = x_raw.flatten()
        tracks[:, 3] = y_raw.flatten()

        return tracks, track_ids


# if we want even more control over our widget, we can use
# magicgui `Container`
class ImageThreshold(Container):
    def __init__(self, viewer: "napari.viewer.Viewer"):
        super().__init__()
        self._viewer = viewer
        # use create_widget to generate widgets from type annotations
        self._image_layer_combo = create_widget(
            label="Image", annotation="napari.layers.Image"
        )
        self._threshold_slider = create_widget(
            label="Threshold", annotation=float, widget_type="FloatSlider"
        )
        self._threshold_slider.min = 0
        self._threshold_slider.max = 1
        # use magicgui widgets directly
        self._invert_checkbox = CheckBox(text="Keep pixels below threshold")

        # connect your own callbacks
        self._threshold_slider.changed.connect(self._threshold_im)
        self._invert_checkbox.changed.connect(self._threshold_im)

        # append into/extend the container with your widgets
        self.extend(
            [
                self._image_layer_combo,
                self._threshold_slider,
                self._invert_checkbox,
            ]
        )

    def _threshold_im(self):
        image_layer = self._image_layer_combo.value
        if image_layer is None:
            return

        image = img_as_float(image_layer.data)
        name = image_layer.name + "_thresholded"
        threshold = self._threshold_slider.value
        if self._invert_checkbox.value:
            thresholded = image < threshold
        else:
            thresholded = image > threshold
        if name in self._viewer.layers:
            self._viewer.layers[name].data = thresholded
        else:
            self._viewer.add_labels(thresholded, name=name)
